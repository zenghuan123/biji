# Games101视频教程 https://www.bilibili.com/video/BV1X7411F744
## 概述
* 光栅化是指将三维几何图形显示到二维屏幕上
* 几何，如何表示曲线，曲面，通过细分获得更复杂的图形
* 光线追踪, 射出一条光线穿过所有像素点，计算交点和阴影效果,继续反射这些光线，直到光线照射到光源上为止。
* 动画, 模拟物体的运动
* 不教OpenGL,DirectX,Vulcan这些图形API，这门课教的是图形学，而不是图形学API
* 学完这门课后，有能力快速掌握图形学api
* 计算机视觉，涉及理解，猜测图上的内容是什么
![转发表和路由选择协议](img/计算机视觉和计算机图形学差别.png)
## 线性代数
* 向量,表示方向和长度
* 单位向量,长度为1的向量，希腊字母 上面加^表示
* 图形学默认的向量通常是列向量
* T 符号代表转置
* ||A|| 代表求长度
![向量表示](img/向量表示.png)
* 点乘,点乘结果是一个数字
![点乘](img/点乘.png)
* 点乘计算
![点乘计算](img/点乘计算.png)
* 点乘作用计算夹角的余弦值，进而计算出夹角
* 投影 b向量投影到a向量
![投影计算](img/投影计算.png)
* 计算垂直的向量
![计算垂直向量](img/计算垂直向量.png)
* 点乘可以计算方向前与后的关系,大于0 在前面，小于0在后面
![前后关系](img/前后关系.png)
* 点乘值越接近1表示两个向量越接近
* 叉乘 右手螺旋定则，a乘以b那么手掌平摊握拳的方向从a到b，拇指方向就是向量的方向
![叉乘](img/叉乘.png)
* 如果是左手坐标系，那么方向要用左手螺旋定则判断,这节课默认为右手系
* 叉乘计算
![叉乘计算](img/叉乘计算.png)
* 叉乘判断左右(顺时针还是逆时针旋转), 将a和b放置到一个平面上，以这个平面建立坐标系，x轴，y轴在这个平面上,如果 a x b 向量和z轴方向相同,那么a旋转到b的方向是逆时针，b向量在a向量的左侧
![叉乘判断左右](img/叉乘判断左右.png)
* 叉乘判断点是否在多边形(凸多边形)内部
AB * AP, BC*BP, CA * CP方向是否一致，一致说明在多边形内部
![叉乘判断点是否在内部](img/叉乘判断点是否在内部.png)
* 向量使用坐标轴上的向量表示
![alt text](img/向量使用坐标轴上的向量表示.png)
* 矩阵 3行2列矩阵
![矩阵](img/矩阵.png)
* 矩阵计算 列数和行数相同的矩阵才能乘法, 3行两列 乘以 2行4列得到3行4列的矩阵
![矩阵计算](img/矩阵计算.png)
* 矩阵没有交换律 B * A 几乎不等于 A * B ，结合律满足
![矩阵没有交换律](img/矩阵没有交换律.png)
* 矩阵和向量相乘
![矩阵和向量相乘](img/矩阵和向量相乘.png)
* 矩阵的转置
![alt text](img/矩阵的转置.png)
* 单位矩阵,如果矩阵乘以A 等于单元矩阵，则称这个矩阵是A的逆
![alt text](img/单位矩阵.png)
* 常量的乘积可以使用矩阵相乘
![alt text](img/常量的乘积可以使用矩阵相乘.png)
## 变换
* modeling(模型变换),Viewing(视图变换)
* Modeling
    * translation 移动
    * rotation 旋转
    * scaling 缩放
* Viewling: 3D to 2D projection(投影)
* 缩放矩阵(scale Matrix)
![缩放矩阵](img/缩放矩阵.png)
* 切变(Shear Matrix)
![切变矩阵](img/切变矩阵.png)
* 三角函数 和差公式
![alt text](img/三角函数和差公式.png)
* 旋转矩阵(默认绕原点逆时针旋转)
![alt text](img/旋转矩阵.png)
* 线性变换都能使用矩阵来表示
* 平移变换 无法使用矩阵乘法来表示
![平移变换](img/平移变换.png)
* 齐次坐标
![齐次坐标](img/齐次坐标.png)
向量最后一位为0可以保证向量平移之后方向不变
* 齐次坐标表示平移
![alt text](img/齐次坐标表示平移.png)
* 齐次坐标，相加减少的意义
![alt text](img/齐次坐标，相加减少的意义.png)
* 最后一位不为1的点表示如下,额外定义
![alt text](img/最后一位不为1的点.png)
点+点表示两个点的中点
* 逆变换,乘以矩阵的逆可以变换为变换前的状态
![alt text](img/逆变换.png)
* 变换的组合
    + 变换的顺序影响结果，矩阵的乘法不满足交换律
    + 矩阵满足结合律，ABC = A(BC),所以可以将An乘以到A1计算得到一个矩阵作为最终的变换矩阵
    ![变换的组合](img/变换的组合.png)
    * 让图形以任意一个点旋转，那么可以将图形先移动到原点，然后旋转后，再平移回去
* 仿射变换 = 线性变换 + 一个平移变换
* 三维变换
![alt text](img/三维旋转.png)
* 欧拉角
![alt text](img/欧拉角.png)
* 旋转矩阵的转置 = 这个旋转矩阵的逆,数学上称这种矩阵为正交矩阵
* View/Camera Transformation(视图/相机变换)
* 通常将camera放置在原点，并且上方向为y轴正方向，看着 -z的方向
    * g指的是朝向也比如-z方向，t表示上方向比如y轴正方向。
    + 任意点的摄像机，将摄像机平移到原点
    * 再旋转g到-z，t 到y,(g x t)到x轴，就可以变换到约定俗成的位置上，这个旋转不好求
    * 所以考虑求将X to (g x t),y to z,z to -g的矩阵
    * 因为旋转矩阵的逆就是他的转置，这样就能得到结果矩阵
    * 变换摄像机时，同样也要变换其他图形，这样摄像机和图形没有相对运动，拍摄的图形是一样的
* 投影,正交投影，透视投影
    + 正交投影不会带来近大远小
    + 人眼更类似透视投影
* 正交投影
    * 将摄相机 放到原点，看向-z 向上方向为y
    * 丢弃z坐标
    * 变换和缩放方形都拉成x和y都在 [-1,1]的范围上就是正交投影
    ![alt text](img/正交投影变换.png)
* 透视投影
    + 齐次坐标中(x,y,z,1) 和(kx,ky,kz,k(k!=0))表示的是同一个点
    + 近平面为n，远平面为f(因为是从-z方向看，n坐标大于f坐标)
    + 透视->正交变换矩阵
    + 可以理解成将远平面挤成和近平面坐标相同，并且近平面和远平面的z轴不变,中心点不变
    + 对于所有的点有以下关系
    + ![alt text](img/投影转正交矩阵.png)
    + 所以变换是和z相关，因为是齐次坐标可以乘以z来进行简化
    + ![alt text](img/投影转正交矩阵2.png)
    + 要得到结果,所以矩阵的第一行，第二行，第四行是能确定的
    + ![alt text](img/投影转正交矩阵3.png)
    + 在近平面和远平面的z都不变, 图形的中点的(x,y,n,1)和(x,y,f,1)变换后的值应该为(nx,ny,n^2,n),(fx,fy,f^2,f)(上面说明虽然表示的点是同一个，但是要都乘以z坐标的值)，这样可以列方程求解,因为坐标的变换规律肯定和x，y坐标无关所以
    + ![alt text](img/投影转正交矩阵4.png)
    + 方程为
    ![alt text](img/投影转正交矩阵5.png)
    + 最后再做一次正交投影就能得到透视投影的变换矩阵
    + ![alt text](img/透视投影矩阵.png)
## 光栅化
* 如何定义一个近平面
    * 宽除以高，aspect ratio 长宽比
    * 视角，能看到的角度范围,垂直的可视角度
    ![alt text](img/视角.png)
* 光栅化，将三维物体画在屏幕上
*  屏幕坐标系,约定x,y为整数，坐标原点在左下角
![alt text](img/屏幕坐标系.png)
* 像素的中间是在(x+0.5,y+0.5)
* 投影完的坐标是[-1,1] 将其转化到[0,width] * [0,height]的空间上，视口变换,下一步将三维的三角面片转为像素
![alt text](img/视口变换.png)
* 光栅化过程中，三角形线段经过了像素的一部分怎么判断像素的颜色，采样，获取像素中心所属的三角面片
![alt text](img/采样.png)
* 判断像素中心是否在三角形里面
![alt text](img/判断像素中心.png)
* 包围盒，不需要从0遍历到max x，0到max y，可以使用三角形的包围盒也就是最小和最大x,y覆盖的范围,还有更好的算法
![alt text](img/包围盒.png)
* 更好的遍历算法
![alt text](img/更好的遍历算法.png)
* 这样采样后，三角形有走样，有锯齿
* 反走样 
* Pre-Filter 做一个模糊(滤波)操作 再做采样 可以反走样
* 先采样再模糊，不行
    * 估计是原本的图形的 是连续的，采样后变成了离散的点再做采样的化因为丢失的信息过多模糊的边界不够大，而先做模糊再采样，模糊的范围够大效果更好
* 滤波，避免某些特定的频率，去掉这些
* 频谱？
* 高通滤波(Hight-pass filter)，只有变化高频的地方保留,保留高频的信息，比如图像的边界
* 低通滤波(Lowpass filter),保留变化低的地方
* 卷积 图形学简化的定义
![alt text](img/卷积.png)
* 反走样方法，增加采样率(提高像素)
* 每个像素点计算三角形的覆盖范围 计算覆盖面积除以像素的面积，计算量大
* MSAA，将一个像素点分成4*4个小的假的像素点，对这些进行采样，显示的时候再进行合并,这是一个近似算法。
* FXAA Fast Approximate AA
* TAA Temporal AA
* Super resolution 超分辨率 拉大一张图片，不想看到锯齿 Super sampling 
* DLSS 使用深度学习

