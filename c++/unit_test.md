## 需要写单元测试 
* 单元测试通常是小型的，自动化独立可执行文件
* 运行完之后不能没有结果，需要一个积极信息表明测试确实通过了
* 单元测试框架 catchorg/Catch2
* 使用单元测试框架 来提供丰富的错误提示
* 即使写的单元测试不全，也要有单元测试
## 好的测试应该是怎么样的
* 我们无法证明程序是对的，只能尝试证明不对或失败
* 我们始终在做可以证伪的假设
* 一个好的测试是   
    * Repeatabel: 可重复的，你每次运行都获取到相同的结果
    * Replicable: 可再现的，其他人运行每次都能得到和你相同的结果
    * Accurate： 正确性，是否正确，如果单元测试失败就意味着有bug
        * 如何做？
        * 确认分支路径
        * 边界测试 
        * 不要把从运行中运行得到的结果作为单元测试的检查结果
    * Precise 精确性，意味着从测试种获取了多少信息，可以多快地从发现出错到意思的哪里错了开始处理
    * Readability: 可读性，必须足够简单
        * 分支和循环应该尽可能少
* 白盒测试，这里指的是知道源代码，可以通过判断内部私有变量的值来测试
    * 单独测试内部的私有方法和变量，c++可以使用frined class来访问
* 黑盒测试，这里是指不知道源代码，只知道他对外暴露的公共方法。
    * 如果测试公共方法时难免碰到要使用多个方法的情况，如果这些都有问题可能导致错误的测试结果
    ```
    class Cup{
        public:
            Cup(),_empty(false){}
            bool IsEmpty(){return !_empty;}
    }
    TEST_CASE("Cup::IsEmpty")
    {
        Cup cup;               //构造方法有错误
        CHECK(cup.IsEmpty());  //判断方法也有错误，但是测试通过
    }
    ```
* 黑盒测试难题，无法判断任何给定的成员函数在孤立的情况下是否正确。
* 使用行为驱动测试，不再逐个判断每个方法的正确性，而是判断在某些状态下能做什么。
    ```
     TEST_CASE("A new cup is empty")
    {
        Cup cup;               
        CHECK(cup.IsEmpty());
    }
    TEST_CASE("An empty cup can be filed")
    {
        Cup cup;
        bool success = cup.fill();
        CHECK(success);
    }
    ```
* 如果测试的每个行为的状态都是反着的(比如_empty不表示空，而表示满),然后测试的每个行为都是正确的，那么代码也是正确的，虽然这样代码质量很差。
* 测试驱动开发
    1. 写一个失败的测试
    2. 写实现让测试通过
    3. 重构代码
    4. 功能是否完成，没完成重新添加测试
    5. 直到功能完成
    